/*
* gargantua/ecs/ecs_entitymanager.ixx
* 
* PURPOSE: Manage id for the ecs.
* 
* CLASSES:
*	EntityManager: Create and destroy id for entities.
* 
* DESCRIPTION:
*	Create, destroy and check if an entity is alive. All the operations are done in 
*	constant time.
*	Check this for more info about the methods used to create/destroy entities:
*	https://skypjack.github.io/2019-05-06-ecs-baf-part-3/
* 
* TODO:
*	- Add checks for generation part overflow when destroy an entity? Or let it round to 0?	
* 
* USAGE:
*	EntityManager mng;
*	auto e1 = mng.Create();
*	
*	// do my operations with e1.
*	...
* 
*	// Destroy the entity when i'm done.
*	mng.Destroy(e1);
* 
*	if (mng.IsAlive(e1))  // return false.
*		...
* 
*/


export module gargantua.ecs.entity_manager;

import <vector>;

import gargantua.types;
import gargantua.ecs.entity;
import gargantua.gen.sequential_generator;

namespace gargantua::ecs
{
	export class EntityManager
	{
	public:
		constexpr explicit EntityManager() : available(0), next(0) 
		{
			
		}


		/*
		* Creates an id and register it to the living entities.
		* Complexity: O(1).
		*/
		[[nodiscard("Entity's id must not be ignored for id leak")]]
		constexpr auto Create() -> entity_t
		{
			//If no entity is available, create a new one.
			if (available == 0)
			{
				entity_t id = EntityManipulation::MakeID(0, g.Next());
				entities.push_back(id);
				return id;
			}

			//Get a recycled entity.
			--available;
			auto temp_next = next;
			next = EntityManipulation::Entity(entities[next]);
			entities[temp_next] = EntityManipulation::InsertEntityInID(entities[temp_next], temp_next);

			return entities[temp_next];
		}


		/*
		* Destroys an id and put its id in a container for reuse.
		* Precondition: The id must be valid (generated by the entity mng and alive before this call).
		* Complexity: O(1).
		*/
		constexpr auto Destroy(entity_t id) -> void
		{
			auto entity = EntityManipulation::Entity(id);
			//increment the generation number 
			auto new_gen = EntityManipulation::Generation(entities[entity]) + 1;
			entities[entity] = EntityManipulation::InsertGenerationInID(entities[entity], new_gen);
			++available;

			//if this is the first entity to be recyled the procedure is a little bit different
			if (available == 1)
			{
				next = entity;
			}
			else
			{
				entities[entity] = EntityManipulation::InsertEntityInID(entities[entity], next);
				next = entity;
			}
		}


		/*
		* Check if an entity is currently used. The check is based on the generation part.
		* Precondition: Entity must be valid.
		* Complexity: O(1).
		*/
		[[nodiscard]]
		constexpr auto IsAlive(entity_t e) const -> bool
		{
			return entities[EntityManipulation::Entity(e)] == e;
		}


	private:
		gen::SequentialGenerator<id_t> g;
		std::vector<id_t> entities;
		u32 available;

		//contains the entity (that is the index in the entities) that can be recycled.
		id_t next;
	}; 
} // namespace gargantua::ecs
